{% extends "base.html" %}

{% block title %}Home - Tasks{% endblock %}

{% block content %}
    <h1>My Tasks</h1>
    
    <div class="form-group">
        <input type="text" id="title" placeholder="Task Title">
        <input type="text" id="deadline" placeholder="Deadline (YYYY-MM-DD)">
        <button onclick="createTask()">Add Work Task</button>
    </div>

    <ul class="task-list">
        {% for task in tasks %}
            <li>
                {{ task.title }} 
                <a href="/edit/{{ task.id }}" class="edit-link">✏️ Редактирай</a>
            </li>
        {% endfor %}
    </ul>
{% endblock %}

{% block scripts %}
<script>
    async function createTask() {
        // Използваме fetch API – модерен начин за пращане на заявки без презареждане на страницата.
        const title = document.getElementById('title').value; // Вземаме стойностите от инпутите
        const deadline = document.getElementById('deadline').value; // Вземаме стойностите от инпутите

        // body: JSON.stringify(...) превръща обекта ни в текст, за да мине през HTTP.
        const response = await fetch('/tasks', {    // Пращаме заявка към нашия /tasks endpoint
            method: 'POST', // Методът е POST, защото създаваме нов ресурс
            headers: { 'Content-Type': 'application/json' }, // Казваме, че пращаме JSON
            body: JSON.stringify({  // Тялото на заявката е JSON обект с данните за новата задача
                title: title,
                deadline: deadline,
                task_type: "Work"
            })
        });

        if (response.ok) { // Ако всичко е минало добре
            window.location.reload();   // Презареждаме страницата, за да видим новата задача
        } else {
            // Връщаме грешка, ако например Pydantic валидацията се провали.
            const errorData = await response.json();    // Вземаме грешката като JSON
            alert("Error: " + JSON.stringify(errorData.detail));    // Показваме я на потребителя
        }
    }
</script>
{% endblock %}